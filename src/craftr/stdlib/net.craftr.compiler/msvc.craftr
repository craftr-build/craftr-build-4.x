# -*- coding: utf8 -*-
# The MIT License (MIT)
#
# Copyright (c) 2018  Niklas Rosenstein
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
Detect MSVC installations on the current system (Windows only).
"""

project('net.craftr.compiler.msvc', '1.0-0')
options('installDir', str, '')
options('version', str, '')
options('arch', str, 'x86' if OS.arch == 'x86' else 'amd64')
options('platformType', str, '')
options('sdkVersion', str, '')

import contextlib
import functools
import json
import nr.types
import nr.fs
import nr.fs as path
import operator
import os
import platform
import re
import subprocess
import sys
import tempfile
import typing as t
import logging as log

import {batchvars} from 'net.craftr.tool.batchvars'
import {v as build_cache} from 'net.craftr.tool.cache'

from craftr.utils import sh

class MsvcInstallation(nr.types.Named):
  """
  Represents an MSVC installation directory.
  """

  _list = None
  __annotations__ = [
    ('version', int),
    ('is_build_tools', bool),
    ('directory', str),
    ('_environ', dict, None),
  ]

  @property
  def vcvarsall(self):
    """
    Generates the path to the `vcvarsall.bat`.
    """

    if self.is_build_tools:
      return path.join(self.directory, 'vcbuildtools.bat')
    elif self.version >= 141:
      return path.join(self.directory, 'VC', 'Auxiliary', 'Build', 'vcvarsall.bat')
    else:
      return path.join(self.directory, 'VC', 'vcvarsall.bat')

  def environ(self, arch=None, platform_type=None, sdk_version=None):
    """
    Executes the `vcvarsall.bat` of this installation with the specified
    *arch* and returns the environment dictionary after that script
    initialized it. If *arch* is omitted, it defaults to the current
    platform's architecture.

    If the specified architecture is incorrect or anything else happens that
    results in the `vcvarsall.bat` to not update the environment, a
    #ValueError is raised.

    If the `vcvarsall.bat` can not be exeuted, #subprocess.CalledProcessError
    is raised.
    """

    if self._environ is not None:
      return self._environ

    arch = options.arch
    if arch == 'x86_64':
      arch = 'x86_amd64'

    args = [arch]
    if platform_type:
      args.append(platform_type)
    if sdk_version:
      args.append(sdk_version)
    return batchvars(self.vcvarsall, *args)

  @classmethod
  def list(cls):
    """
    List all available MSVC installations.
    """

    if cls._list is not None:
      return cls._list

    # Check all VS_COMNTOOLS environment variables.
    results = []
    for key, value in os.environ.items():
      if not (key.startswith('VS') and key.endswith('COMNTOOLS')):
        continue
      try:
        ver = int(key[2:-9])
      except ValueError:
        continue

      # Clean up the directory name.
      value = value.rstrip('\\')
      if not value or not path.isdir(value):
        continue
      if path.base(value).lower() == 'tools':
        # The VS_COMNTOOLS variable points to the Common7\Tools
        # subdirectory, usually.
        value = path.dir(path.dir(value))

      results.append(cls(ver, False, value))

    build_tools_dir = r'C:\Program Files (x86)\Microsoft Visual C++ Build Tools'
    if path.isdir(build_tools_dir):
      # TODO: Is there a (good) way to determine the versio of the Build Tools?
      #       It seems there is no version information besides the year in the
      #       filenames of the links that open respective consoles.
      results.append(cls(140, True, build_tools_dir))

    have_versions = set(x.version for x in results)

    # Special handling for MSVC 2017.
    # TODO: Can MSVC 2017 be installed in an alternative location?
    if 141 not in have_versions:
      programfiles = os.getenv('ProgramFiles(x86)', '') or os.getenv('ProgramFiles', '')
      if programfiles:
        vspath = path.join(programfiles, 'Microsoft Visual Studio\\2017\\Community')
        if not path.isdir(vspath):
          vspath = path.join(programfiles, 'Microsoft Visual Studio\\2017\\Professional')
        if not path.isdir(vspath):
          vspath = path.join(programfiles, 'Microsoft Visual Studio\\2017\\Enterprise')
        if path.isdir(vspath):
          results.append(cls(141, False, vspath))

    # TODO: Special handling for newer MSVC versions?

    result = sorted(results, key=operator.attrgetter('version'), reverse=True)

    # Special handling for explicitly defined MSVC install directory.
    if options.installDir:
      if not path.exists(options.installDir):
        log.warn('msvc.install_dir={!r} does not exist'.format(options.installDir))
      else:
        result.insert(0, cls(-1, options.installDir))

    cls._list = result
    return cls._list


class AsDictJSONEncoder(json.JSONEncoder):

  def default(self, obj):
    if hasattr(obj, '_asdict'):
      return obj._asdict()
    elif hasattr(obj, 'asdict'):
      return obj.asdict()
    return super().default(obj)


class InvalidToolset(RuntimeError):

  def __init__(self, message, program, info):
    self.program = program
    self.message = message
    self.info = info

  def __str__(self):
    return '{}\n\nProgram: {}\n\n{}'.format(self.message, self.program, self.info)


class ClInfo(nr.types.Named):

  __annotations__ = [
    ('version', str),
    ('version_str', str),
    ('target', str),  # Either x86 or x64
    ('msvc_deps_prefix', str, None),
    ('assembler_program', str),
    ('link_program', str),
    ('lib_program', str),
    ('error', InvalidToolset, None)
  ]

  VERSION_REGEX = re.compile(r'compiler\s+version\s*([\d\.]+)\s*\w+\s*(x\w+)', re.I | re.M)

  @classmethod
  def from_program(cls, program, env=None):
    with sh.override_environ(env or {}):
      version_output = subprocess.check_output([program], stderr=subprocess.STDOUT).decode()
    match = cls.VERSION_REGEX.search(version_output)
    if not match:
      raise RuntimeError('ClInfo could not be detected from {!r}'
        .format(program))

    version = match.group(1)
    arch = match.group(2)

    # Determine the msvc_deps_prefix by making a small test. The
    # compilation will not succeed since no entry point is defined.
    deps_prefix = None
    with tempfile.NamedTemporaryFile(suffix='.cpp', delete=False) as fp:
      fp.write(b'#include <cstddef>\n')
      fp.close()
      command = [program, '/Zs', '/showIncludes', fp.name, '/nologo']
      with sh.override_environ(env or {}):
        try:
          output = sh.run(command, stderr=sh.STDOUT, stdout=sh.PIPE, check=False).stdout.decode()
        finally:
          os.remove(fp.name)

      # Find the "Note: including file:" in the current language. We
      # assume that the structure is the same, only the words different.
      # After the logo output follows the filename followed by the include
      # notices.
      error = None
      for line in output.split('\n'):
        if 'cstddef' in line:
          if 'C1083' in line or 'C1034' in line:
            # C1083: can not open include file
            # C1034: no include path sep
            msg = 'Can not compile a simple C++ program (MSVC {} {})'
            with sh.override_environ(env or {}):
              error = InvalidToolset(msg.format(version, arch),
                sh.which(program) or program, output)
          match = re.search('[\w\s]+:[\w\s]+:', line)
          if match:
            deps_prefix = match.group(0)

    return cls(
      version = version,
      version_str = version_output.split('\n', 1)[0].strip(),
      target = arch,
      msvc_deps_prefix = deps_prefix,
      assembler_program = 'ml64' if arch == 'x64' else 'ml',
      link_program = 'link',
      lib_program = 'lib',
      error = error
    )


class MsvcToolkit(nr.types.Named):
  """
  Similar to a #MsvcInstallation, this class represents an MSVC
  installation, however it is fixed to a specific target architecture and
  Windows SDK, etc. Additionally, it can be saved to and loaded from disk.
  """

  CSC_VERSION_REGEX = re.compile(r'compiler\s+version\s+([\d\.]+)', re.I | re.M)

  __annotations__ = [
    ('version', int),
    ('directory', str),
    ('environ', dict, None),
    ('arch', str, None),
    ('platform_type', str, None),
    ('sdk_version', str, None),
    ('_csc_version', str, None),
    ('_vbc_version', str, None),
    ('_cl_info', ClInfo, None),
    ('_deps_prefix', str, None)
  ]

  @classmethod
  def from_installation(cls, inst, arch=None, platform_type=None, sdk_version=None):
    environ = inst.environ(arch, platform_type, sdk_version)
    return cls(inst.version, inst.directory, environ, arch, platform_type, sdk_version)

  @classmethod
  def fromdict(cls, data):
    if data.get('_cl_info'):
      data['_cl_info'] = ClInfo(**data['_cl_info'])
    return cls(**data)

  @classmethod
  @functools.lru_cache()
  def from_config(cls):
    installations = MsvcInstallation.list()
    if not installations:
      raise RuntimeError('Unable to detect any MSVC installation. Is it installed?')

    version = options.version
    if version:
      version = int(version)
      install = next((x for x in installations if x.version == version), None)
      if not install:
        raise RuntimeError('MSVC version "{}" is not available.'.format(version))
    else:
      install = installations[0]
      version = install.version

    arch = options.arch
    platform_type = options.platformType
    sdk_version = options.sdkVersion

    cache = None
    cache_key = 'craftr/tools/msvc'
    if cache_key in build_cache:
      cache = cls.fromdict(build_cache[cache_key])

    key_info = (version, arch, platform_type, sdk_version)
    if not cache or cache.key_info != key_info:
      toolkit = cls.from_installation(install, arch, platform_type, sdk_version)
      build_cache[cache_key] = toolkit.asdict()
    else:
      toolkit = cache  # Nothing has changed

    return toolkit

  @property
  def key_info(self):
    return (self.version, self.arch, self.platform_type, self.sdk_version)

  @property
  def vs_year(self):
    if self.version == 90: return 2008
    elif self.version == 100: return 2010
    elif self.version == 110: return 2012
    elif self.version == 120: return 2013
    elif self.version == 140: return 2015
    elif self.version == 141: return 2017
    else: raise ValueError('unknown MSVC version: {!r}'.format(self.version))

  @property
  def csc_version(self):
    if not self._csc_version:
      with sh.override_environ(self.environ):
        try:
          output = subprocess.check_output(['csc', '/version'], stderr=subprocess.STDOUT).decode()
        except subprocess.CalledProcessError as e:
          # Older versions of CSC don't support the /version flag.
          match = self.CSC_VERSION_REGEX.search(e.stdout.decode())
          if not match:
            raise
          output = match.group(1)
        self._csc_version = output.strip()
    return self._csc_version

  @property
  def cl_version(self):
    return self.cl_info.version

  @property
  def cl_info(self):
    if not self._cl_info:
      self._cl_info = ClInfo.from_program('cl', self.environ)
    return self._cl_info

  @property
  def vbc_version(self):
    if not self._vbc_version:
      with sh.override_environ(self.environ):
        output = subprocess.check_output(['vbc', '/version']).decode()
        self._vbc_version = output.strip()
    return self._vbc_version

  @property
  def deps_prefix(self):
    """
    Returns the string that is the prefix for the `/showIncludes` option
    in the `cl` command.
    """

    if self._deps_prefix:
      return self._deps_prefix
    return self.cl_info.msvc_deps_prefix

  @classmethod
  @functools.lru_cache()
  def get(cls):
    toolkit = cls.from_config()
    log.info('MSVC v{}-{} ({})'.format(
      toolkit.version, toolkit.arch, toolkit.directory))
    return toolkit


def main(argv=None, prog=None):
  import argparse
  parser = argparse.ArgumentParser(prog=prog, allow_abbrev=False)
  parser.add_argument('--json', action='store_true', help='Output in JSON format.')
  parser.add_argument('argv', nargs='...')
  args = parser.parse_args(argv)

  installs = MsvcInstallation.list()
  if args.argv:
    with sh.override_environ(installs[0].environ()):
      return subprocess.call(args.argv)

  if args.json:
    result = []
    for inst in installs:
      data = {"version": inst.version, "directory": inst.directory}
      result.append(data)
    print(json.dumps(result, indent=2))
  else:
    if not installs:
      log.error('no MSVC installations could be detected.')
      return 1
    for inst in installs:
      tk = MsvcToolkit.from_installation(inst)
      version = tk.cl_info.version
      print('- {}: {}'.format(inst.version, inst.directory))
      print('  cl Version: {}'.format(tk.cl_info.version))
      if tk.cl_info.error:
        print('  ERROR: {}'.format(tk.cl_info.error.message))
        for line in tk.cl_info.error.info.split('\n'):
          print('         {}'.format(line))
      print()
